{"meta":{"title":"ThisLX","subtitle":"the stack of it nerds","description":"ThisLX Blog","author":"ThisLX","url":"http://inerdstack.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"SQL优化面试题整理","date":"2019-04-12T02:10:11.903Z","updated":"2019-04-04T07:09:02.312Z","comments":true,"path":"2019/04/12/SQL优化面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/SQL优化面试题整理/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringBoot面试题整理","slug":"SpringBoot面试题整理","date":"2019-04-12T02:10:11.898Z","updated":"2019-04-12T02:09:11.273Z","comments":true,"path":"2019/04/12/SpringBoot面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/SpringBoot面试题整理/","excerpt":"","text":"1、Spring Boot 的核心配置文件有哪几个？它们的区别是什么？ Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。bootstrap 配置文件有以下几个应用场景。 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息； 一些固定的不能被覆盖的属性； 一些加密/解密的场景； 2、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？ 启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解： @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。 3、开启 Spring Boot 特性有哪几种方式？ 继承spring-boot-starter-parent项目 导入spring-boot-dependencies项目依赖 4、Spring Boot 需要独立的容器运行吗？ 可以不需要，内置了 Tomcat/ Jetty 等容器。 5、SpringBoot 实现热部署有哪几种方式？ 主要有两种方式： Spring Loaded Spring-boot-devtools 6、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？ 配置变更 JDK 版本升级 第三方类库升级 响应式 Spring 编程支持 HTTP/2 支持 配置属性绑定 更多改进与加强 7、springboot项目需要兼容老项目（spring框架）,该如何实现. 集成老项目spring框架的容器配置文件即可:spring-boot一般提倡零配置.但是如果需要配置,也可增加:@ImportResource({“classpath:spring1.xml” , “classpath:spring2.xml”})注意:resources/spring1.xml位置. 8、springboot支持的默认日志框架是什么 spring-boot: 默认采用Logback作为日志框架. 9、什么是JavaConfig？ Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于： 面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。 减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。 JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。 从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。 类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。 10、Spring Boot中的监视器是什么？ Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。 11、如何实现Spring Boot应用程序的安全性？ 为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。 12、如何实现Spring Boot应用程序的安全性？ 为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。","categories":[],"tags":[]},{"title":"Solr+ES面试题整理","slug":"Solr+ES面试题整理","date":"2019-04-12T02:10:11.896Z","updated":"2019-04-12T02:08:56.179Z","comments":true,"path":"2019/04/12/Solr+ES面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Solr+ES面试题整理/","excerpt":"","text":"1、Solr原理Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程 2、Solr基于什么基于lucene搜索库的一个搜索引擎框架，lucene是一个开放源码的全文检索引擎工具包 3、Solr怎么设置搜索结果排名靠前设置文档中域的boost值，值越高相关性越高，排名就靠前 4、Solr的索引查询为什么比数据库要快Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快 5、Solr如何分词，新增词和禁用词如何解决schema.xml文件中配置一个IK分词器，然后域指定分词器为IK新增词添加到词典配置文件中ext.dic，禁用词添加到禁用词典配置文件中stopword.dic，然后在schema.xml文件中配置禁用词典： 6、IK分词器原理 本质上是词典分词，在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有词语拆分出来的过程 7、Lucence 内部结构是什么索引(Index)： 在Lucene中一个索引是放在一个文件夹中的。 如上图，同一文件夹中的所有的文件构成一个Lucene索引。段(Segment)： 一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。segments.gen和segments_X是段的元数据文件，也即它们保存了段的属性信息。文档(Document)： 文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。域(Field)： 一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。 不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。词(Term)： 词是索引的最小单位，是经过词法分析和语言处理后的字符串。 8、Elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch 的倒排索引是什么。ElasticSearch（简称ES）是一个分布式、Restful的搜索及分析服务器，设计用于分布式计算；能够达到实时搜索，稳定，可靠，快速。和Apache Solr一样，它也是基于Lucence的索引服务器，而ElasticSearch对比Solr的优点在于：轻量级：安装启动方便，下载文件之后一条命令就可以启动。Schema free：可以向服务器提交任意结构的JSON对象，Solr中使用schema.xml指定了索引结构。多索引文件支持：使用不同的index参数就能创建另一个索引文件，Solr中需要另行配置。分布式：Solr Cloud的配置比较复杂。 9、Elasticsearch 与 Solr 的比较： 二者安装都很简单； Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能; Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式； Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供； Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。 Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。 10、Elasticsearch 索引数据多了怎么办，如何调优，部署。 使用bulk API 初次索引的时候，把 replica 设置为 0 增大 threadpool.index.queue_size 增大 indices.memory.index_buffer_size 增大 index.translog.flush_threshold_ops 增大 index.translog.sync_interval 增大 index.engine.robin.refresh_interval详细：http://www.jianshu.com/p/5eeeeb4375d4 11、Elasticsearch是如何实现Master选举的 Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分； 对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。 12、Elasticsearch是如何避免脑裂现象的 当集群中master候选的个数不小于3个（node.master: true）。可以通过discovery.zen.minimum_master_nodes 这个参数的设置来避免脑裂，设置为(N/2)+1。 假如集群master候选节点为2的时候，这种情况是不合理的，最好把另外一个node.master改成false。如果我们不改节点设置，还是套上面的(N/2)+1公式，此时discovery.zen.minimum_master_nodes应该设置为2。这就出现一个问题，两个master备选节点，只要有一个挂，就选不出master了。 13、客户端在和集群连接时，如何选择特定的节点执行请求的？TransportClient利用transport模块远程连接一个elasticsearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以 轮询 的方式与这些地址进行通信。 14、在并发情况下，Elasticsearch如果保证读写一致？ 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突； 另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。 15、Elasticsearch在部署时，对Linux的设置有哪些优化方法？ 64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反。 如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。 如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。 即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。 请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。 通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。 Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。 不要随意修改垃圾回收器（CMS）和各个线程池的大小。 把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。 内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。 Lucene 使用了大量的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。 补充：索引阶段性能提升方法 使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。 段和段合并：Elasticsearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD，可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。 如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。 如果你在做大批量导入，考虑通过设置index.number_of_replicas: 0 关闭副本。 16、对于GC方面，在使用Elasticsearch时要注意什么？ SEE：https://elasticsearch.cn/article/32 倒排词典的索引需要常驻内存，无法GC，需要监控data node上segment memory增长趋势。 各类缓存，field cache, filter cache, indexing cache, bulk queue等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗？避免采用clear cache等“自欺欺人”的方式来释放内存。 避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现。 cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。 想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。","categories":[],"tags":[]},{"title":"Shiro面试题整理","slug":"Shiro面试题整理","date":"2019-04-12T02:10:11.894Z","updated":"2019-04-12T02:08:41.275Z","comments":true,"path":"2019/04/12/Shiro面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Shiro面试题整理/","excerpt":"","text":"1、Shiro 的优点 简单的身份认证, 支持多种数据源 对角色的简单的授权, 支持细粒度的授权(方法级) 支持一级缓存，以提升应用程序的性能； 内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境 非常简单的加密 API 不跟任何的框架或者容器捆绑, 可以独立运行 2、比较 SpringSecurity 和 Shiro 相比 Spring Security, Shiro 在保持强大功能的同时, 使用简单性和灵活性 SpringSecurity: 即使是一个一个简单的请求，最少得经过它的 8 个FilterSpringSecurity 必须在 Spring 的环境下使用，初学Spring Security, 曲线还是较大, 需要深入学习其源码和框架, 配置起来也较费力. 3、简述 Shiro 的核心组件 Shiro 架构 3 个核心组件: Subject: 正与系统进行交互的人, 或某一个第三方服务. 所有 Subject 实例都被绑定到（且这是必须的）一个SecurityManager 上。 SecurityManager: Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务，当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。 Realms: 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和/或授权，Shiro 提供了多种可用的，Realms 来获取安全相关的数据. 如关系数据库(JDBC), INI 及属性文件等，也可以定义自己 Realm 实现来代表自定义的数据源。 4、Shiro认证过程 ①. 应用程序代码调用 Subject.login 方法，传递创建好的包含终端用户的 Principals(身份)和 Credentials(凭证)的 AuthenticationToken 实例 ②. Subject 实例: 通常为 DelegatingSubject(或子类)委托应用程序的 SecurityManager 通过调用securityManager.login(token) 开始真正的验证。 ③. SubjectManager 接收 token，调用内部的 Authenticator 实例调用 authenticator.authenticate(token).Authenticator 通常是一个 ModularRealmAuthenticator 实例, 支持在身份验证中协调一个或多个Realm 实例 ④. 如果应用程序中配置了一个以上的 Realm, ModularRealmAuthenticator 实例将利用配置好的AuthenticationStrategy 来启动 Multi-Realm 认证尝试. 在Realms 被身份验证调用之前, 期间和以后,AuthenticationStrategy 被调用使其能够对每个Realm 的结果作出反应. ⑤. 每个配置的 Realm 用来帮助看它是否支持提交的 AuthenticationToken. 如果支持, 那么支持 Realm 的 getAuthenticationInfo 方法将会伴随着提交的 token 被调用. getAuthenticationInfo 方法有效地代表一个特定 Realm 的单一的身份验证尝试。 5、Shiro授权过程 ①. 应用程序或框架代码调用任何 Subject 的hasRole, checkRole, isPermitted,或者checkPermission方法的变体, 传递任何所需的权限 ②. Subject 的实例—通常是 DelegatingSubject(或子类), 调用securityManager 的对应的方法. ③. SecurityManager 调用 org.apache.shiro.authz.Authorizer 接口的对应方法.默认情况下，authorizer 实例是一个 ModularRealmAuthorizer 实例, 它支持协调任何授权操作过程中的一个或多个Realm 实例 ④. 每个配置好的 Realm 被检查是否实现了相同的 Authorizer 接口. 如果是, Realm 各自的 hasRole, checkRole,isPermitted，或 checkPermission 方法将被调用。 6、Shiro 如何自实现认证 Shiro 的认证过程由 Realm 执行, SecurityManager 会调用 org.apache.shiro.realm.Realm 的 getAuthenticationInfo(AuthenticationToken token) 方法. 实际开发中, 通常提供 org.apache.shiro.realm.AuthenticatingRealm 的实现类, 并在该实现类中提供 doGetAuthenticationInfo(AuthenticationToken token)方法的具体实现 7、如何实现自实现授权 实际开发中, 通常提供 org.apache.shiro.realm.AuthorizingRealm 的实现类, 并提供 doGetAuthorizationInfo(PrincipalCollection principals) 方法的具体实现 8、如何配置在 Spring 中配置使用 Shiro ①. 在 web.xml 中配置 Shiro 的 Filter ②. 在 Spring 的配置文件中配置 Shiro: 配置自定义 Realm：实现自定义认证和授权 配置 Shiro 实体类使用的缓存策略 配置 SecurityManager 配置保证 Shiro 内部 Bean 声明周期都得到执行的 Lifecycle Bean 后置处理器 配置AOP 式方法级权限检查 配置 Shiro Filter","categories":[],"tags":[]},{"title":"Redis面试题整理","slug":"Redis面试题整理","date":"2019-04-12T02:10:11.892Z","updated":"2019-04-12T02:08:26.898Z","comments":true,"path":"2019/04/12/Redis面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Redis面试题整理/","excerpt":"","text":"1、什么是Redis？简述它的优缺点？ Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。 因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。 比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。 另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 2、Redis支持哪几种数据类型？ String、List、Set、Sorted Set、hashes 3、Redis有哪几种数据淘汰策略？ noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 vlatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 4、一个字符串类型的值能存储最大容量是多少？512M 5、为什么Redis需要把所有数据放到内存中？ Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 6、Redis集群最大节点个数是多少？16384个。 7、Redis有哪些适合的场景？ 会话缓存（Session Cache）最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 全页缓存（FPC）除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 队列Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。 排行榜/计数器Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORESAgora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 发布/订阅最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！ 10、Redis集群方案应该怎么做？都有哪些方案？ twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。 codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。 redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。 在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。 11、Redis支持的Java客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 12、Jedis与Redisson对比有什么优缺点？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 13、说说Redis哈希槽的概念？ Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 14、Redis集群的主从复制模型是怎样的？ 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品. 15、Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 16、Redis中的管道有什么用？ 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 17、怎么理解Redis事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 18、Redis事务相关的命令有哪几个？MULTI、EXEC、DISCARD、WATCH 19、Redis如何做内存优化？尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面. 详细请看：https://blog.csdn.net/u010682330/article/details/81043419","categories":[],"tags":[]},{"title":"Nginx面试题整理","slug":"Nginx面试题整理","date":"2019-04-12T02:10:11.890Z","updated":"2019-04-12T02:08:00.660Z","comments":true,"path":"2019/04/12/Nginx面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Nginx面试题整理/","excerpt":"","text":"1、请解释一下什么是Nginx? Nginx是一个web服务器和方向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。 2、Nginx和apache的区别？ 轻量级，同样起web 服务，比apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 高度模块化的设计，编写模块相对简单 最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 3、Nginx是如何实现高并发的 答：一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker继续处理其他请求，而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。由于web server的工作性质决定了每个request的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即@skoo所说的webserver刚好属于网络io密集型应用，不算是计算密集型。 4、请解释Nginx如何处理HTTP请求 Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。 5、使用“反向代理服务器”的优点是什么? 反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。 6、请列举Nginx服务器的最佳用途。 Nginx服务器的最佳用法是在网络上部署动态HTTP内容，使用SCGI、WSGI应用程序服务器、用于脚本的FastCGI处理程序。它还可以作为负载均衡器。 7、请解释Nginx服务器上的Master和Worker进程分别是什么? Master进程：读取及评估配置和维持 Worker进程：处理请求 8、在Nginx中，解释如何在URL中保留双斜线? 要在URL中保留双斜线，就必须使用merge_slashes_off; 语法:merge_slashes [on/off] 默认值: merge_slashes on 环境: http，server 9、请解释ngx_http_upstream_module的作用是什么? ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和scgi传递指令来引用的服务器组。 10、请解释什么是C10K问题? C10K问题是指无法同时处理大量客户端(10,000)的网络套接字。 11、请陈述stub_status和sub_filter指令的作用是什么? Stub_status指令：该指令用于了解Nginx当前状态的当前状态，如当前的活动连接，接受和处理当前读/写/等待连接的总数 Sub_filter指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据 12、解释Nginx是否支持将请求压缩到上游? 您可以使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应。 13、解释如何在Nginx中获得当前的时间? 要获得Nginx的当前时间，必须使用SSI模块、$date_gmt和$date_local的变量。Proxy_set_header THE-TIME $date_gmt; 18、用Nginx服务器解释-s的目的是什么? 用于运行Nginx -s参数的可执行文件。 19、解释如何在Nginx服务器上添加模块? 在编译过程中，必须选择Nginx模块，因为Nginx不支持模块的运行时间选择。","categories":[],"tags":[]},{"title":"MQ面试题整理","slug":"MQ面试题整理","date":"2019-04-12T02:10:11.887Z","updated":"2019-04-12T02:07:15.710Z","comments":true,"path":"2019/04/12/MQ面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/MQ面试题整理/","excerpt":"","text":"1、Activemq的作用以及原理Activemq 的作用就是系统之间进行通信。 当然可以使用其他方式进行系统间通信， 如果使用 Activemq 的话可以对系统之间的调用进行解耦， 实现系统间的异步通信。 原理就是生产者生产消息， 把消息发送给activemq。 Activemq 接收到消息， 然后查看有多少个消费者， 然后把消息转发给消费者， 此过程中生产者无需参与。 消费者接收到消息后做相应的处理和生产者没有任何关系 3.消息重复消费问题可能原因：发送时消息重复、投递时消息重复消费者的接口要实现等幂性方法一：全局唯一ID：根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。方法二：去重表，建立一个去重表，去重表中设置唯一索引，如果去重表插入成功则执行方式三：多版本控制 2、activemq消息丢失如何处理情况一：发送到broker时消息丢失解决：先持久到数据库，发送成功后删除或者标记删除。定时任务处理 情况二：broker崩溃解决：消息持久化 情况三：broker到消费端出问题解决：逻辑整理使其可以重新发送（如，发送时持久化消息并置状态为已发送，消费成功则置为已消费），当然消费要实现等幂性情况一：发送到broker时消息丢失解决：先持久到数据库，发送成功后删除或者标记删除。定时任务处理 情况二：broker崩溃解决：消息持久化 情况三：broker到消费端出问题解决：逻辑整理使其可以重新发送（如，发送时持久化消息并置状态为已发送，消费成功则置为已消费），当然消费要实现等幂性 3、消费顺序性如何保证方案一：保证需要排序的消息按照先后顺序发送到同一个消费队列中，并且这个队列只有一个相应的消费者方案二：通过业务限制，保证前消息被消费完，才可以发送后消息","categories":[],"tags":[]},{"title":"Mongodb面试题整理","slug":"Mongodb面试题整理","date":"2019-04-12T02:10:11.884Z","updated":"2019-04-12T02:06:53.691Z","comments":true,"path":"2019/04/12/Mongodb面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Mongodb面试题整理/","excerpt":"","text":"1、使用mongodb的优点 面向文件 高性能 高可用 易扩展 可分片 对数据存储友好 2、MongoDB支持存储过程吗？如果支持的话，怎么用？ MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。 3、MySQL和MongoDB之间最基本的区别是什么？ 关系型数据库与非关系型数据库的区别，即数据存储结构的不同。 4、如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？ GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。 5、如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？ 如果一个分片停止了，除非查询设置了“Partial”选项，，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。 6、 Mongodb 的索引注意事项？ 索引很有用,但是它也是有成本的——它占内存,让写入变慢； mongoDB通常在一次查询里使用一个索引,所以多个字段的查询或者排序需要复合索引才能更加高效； 复合索引的顺序非常重要 在生成环境构建索引往往开销很大,时间也不可以接受,在数据量庞大之前尽量进行查询优化和构建索引； 避免昂贵的查询,使用查询分析器记录那些开销很大的查询便于问题排查； 通过减少扫描文档数量来优化查询,使用explai对开销大的查询进行分析并优化； 索引是用来查询小范围数据的，不适合使用索引的情况：  每次查询都需要返回大部分数据的文档，避免使用索引  写比读多 7、分析器在MongoDB中的作用是什么? MongoDB中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引。 8、 Mongodb允许空值null吗? 对于对象成员而言，是的。然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象。然而用户能够添加空对象{}。 9、 如何执行事务/加锁? MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQL MylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。 10、分片(sharding)和复制(replication)是怎样工作的? 每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群。 11、 我怎么查看 Mongo 正在使用的链接? db._adminCommand(“connPoolStats”); 12、什么是master或primary? 它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成primary。 13、什么是secondary或slave?Seconday从当前的primary上复制相应的操作。它是通过跟踪复制oplog(local.oplog.rs)做到的。","categories":[],"tags":[]},{"title":"JVM面试题整理","slug":"JVM面试题整理","date":"2019-04-12T02:10:11.882Z","updated":"2019-04-12T02:06:30.161Z","comments":true,"path":"2019/04/12/JVM面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/JVM面试题整理/","excerpt":"","text":"1、JVM内存模型都有哪些 程序计数器 java虚拟机栈 本地方法栈 java堆 方法区 运行时常量池 直接内存 2、讲讲什么情况下会出现内存溢出，内存泄漏 内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。 3、说说Java线程栈 Java线程栈从线程创建时存在，并且是私有的。线程栈用户存储栈帧，栈帧用于存储局部变量、中间运算结果。所以局部是不存在并发的问题，因为每个栈是私有的。虚拟机只会对Java栈进行二种操作：以栈帧为单位的压栈和出栈。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 4、类的实例化顺序 1.首先是父类的静态变量和静态代码块（看两者的书写顺序）；2.第二执行子类的静态变量和静态代码块（看两者的书写顺序）；3.第三执行父类的成员变量赋值4.第四执行父类类的构造代码块5.第五执行父类的构造方法（）6.执行子类的构造代码块7.第七执行子类的构造方法（）；总结，也就是说虽然客户端代码是new 的构造方法，但是构造方法确实是在整个实例创建中的最后一个调用。切记切记！！！先是父类，再是子类；先是类静态变量和静态代码块，再是对象的成员变量和构造代码块–》构造方法。记住，构造方法最后调用！！！！成员变量优先构造代码块优先构造方法！！ 5、java类加载机制 加载：通过类的全限定名获取类的二进制字节流，将字节流代表的静态存储结构转化为方法区的运行时数据结构。在内存生成这个类的class对象 连接：包括三步验证，准备，解析验证：保证class文件的字节流中包含的信息符合当前虚拟机的要求，且不危害虚拟机自身安全准备：正式为类变量分配内存并设置类变量初始值解析：将常量池的符号引用替换为直接引用 初始化：根据程序员的意愿初始化类变量 6、一个对象的内存划分是怎样的？ 可分为3块区域：对象头，实例数据，对齐填充 对象头由Mark world和类型指针组成mark World包括hash码，GC分代年龄，锁状态标志等。类型指针来确定这个对象是哪个类的实例 实例数据是对象存储的真正的有效信息 hostspot虚拟机要求对象的大小必须是8字节的整数倍 7、内存泄漏和内存溢出的区别 内存泄漏：分配出去的内存无法回收（可达却无用的对象无法被gc回收）内存溢出：程序要求的内存超出了系统能分配的范围（如栈满进栈，栈空出栈） 8.垃圾收集算法有哪些 标记-清除算法：首先标记出所有的对象，标记完成后统一回收（1效率问题：标记和清除两个过程效率都不高（2空间问题：产生碎片 复制算法：将内存划分为一块较大的Eden空间（80%）和两块较小的Survivor空间（10%），每次使用Eden和其中的一块Survivor，当回收时，将两者中存活的对象一次性复制到另一块Survivor，并清空刚才用到的空间，如果这块Survivor不够，则启用分配担保机制，将多处的对象存储再老年代 标记-整理算法：首先标记出所有的对象，回收时让存活的对象都向一端移动，直接清理端边界外的内存 分代收集算法：将java堆分为新生代和老年代，垃圾回收时，新生代每次都有大量对象死去，所以采用复制算法，老年代存活的对象较多，使用标记-清除或标记-整理 9、常见的垃圾收集器？ Serial收集器：单线程收集器 ParNew收集器：，新生代收集器，Serial收集器的多线程版本 Parallel Scavenge收集器：新生代收集器，使用复制算法。是用来实现最大吞吐量（代码运行时间/（代码运行时间+垃圾收集的时间）） Serial Old收集器：Serial收集器的老年代版本 Parallel Old收集器：ParNew收集器的老年代版本(一般使用Parallel Scavenge + Parallel Old) CMS收集器：是一种以获取最短停顿时间为目标的收集器。分为4个步骤：初始标记，并发标记，重新标记，并发清除采用 标记-清除算法（1初始标记：标记GC Root能直接关联到的对象 （stop the world）（2并发标记：进行Gc Root Tracing的过程（3重新标记：修正并发标记期间用户线程序继续工作而导致的标记的变动（stop the world）（4并发清除：清除未被标记的对象 （7）G1收集器：可以独立的管理整个gc堆。步骤：初始标记，并发标记，最终标记，筛选回收（首先对各个Region价值排序）从整体上看是：标记-整理算法 ， 从局部上看（两个region）采用复制算法 10、什么情况下对象进入老年代 大对象直接进入老年代（需要大量连续空间的对象）。常见的大对象就是很长的字符串和数组 长期存活的对象进入老年代。每个对象有一个年龄计数器。每熬过一次moinor gc，年龄就增加一岁。当年龄增加到一定程度（默认为15）就会晋升到老年代（通过MaxTenuringThreshold设置）。 动态年龄判断：如果survivor空间某个年龄对象的大小大于survivor空间的一半，年龄大于或等于的直接进入老年代 空间分配担保：复制算法中，survivor中无法容纳的对象将通过分配担保机制直接进入老年代 11、什么时候进行GC 程序员不能控制具体的时间Eden区满了会触发minor GC，老年代满或调用system.gc执行Full GC","categories":[],"tags":[]},{"title":"Dubbo面试题整理","slug":"Dubbo面试题整理","date":"2019-04-12T02:10:11.879Z","updated":"2019-04-12T02:05:54.147Z","comments":true,"path":"2019/04/12/Dubbo面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Dubbo面试题整理/","excerpt":"","text":"1、dubbo都支持什么协议，推荐用哪种？ dubbo://（推荐） rmi:// hessian:// http:// webservice:// thrift:// memcached:// redis:// rest:// 2、Dubbo需要 Web 容器吗？ 不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。 3、Dubbo内置了哪几种服务容器？ Spring Container Jetty Container Log4j Container 4、Dubbo里面有哪几种节点角色？| 节点 | 角色说明|| ——— | ——– || Provider | 暴露服务的服务提供方 || Consumer | 调用远程服务的服务消费方|| Registry | 服务注册于发现的注册中心 || Monitor | 统计服务的调用次数和调用时间的监控中间 || Container | 服务运行容器 | 5、Dubbo默认使用什么注册中心，还有别的选择吗？ 推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。 6、Dubbo推荐使用什么序列化框架，你知道的还有哪些？ 推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。 7、Dubbo默认使用的是什么通信框架，还有别的选择吗？ Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。 8、服务上线怎么兼容旧版本？ 可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。 9、在 Provider 上可以配置的 Consumer 端的属性有哪些？ timeout：方法调用超时 retries：失败重试次数，默认重试 2 次 loadbalance：负载均衡算法，默认随机 actives 消费者端，最大并发调用限制 10、Dubbo有哪几种集群容错方案，默认是哪种？| 集群容错方案 | 说明|| ——— | ——– || Failover Cluster | 失败自动切换，自动重试其他服务器（默认） || Failfast Cluster |快速失败，立即报错，只发起一次调用|| Failsafe Cluster |失败安全，出现异常时，直接忽略 || Failback Cluster| 失败自动恢复，记录失败请求，定时重发 || Forking Cluster| 并行调用多个服务器，只是一个成功即返回 || Broadcast Cluster| 广播逐个调用所有提供者，任意一个报错则报错 | 11、Dubbo有哪几种负载均衡策略，默认是哪种？|负载均衡策略 | 说明|| ——— | ——– || Random LoadBalance | 随机，按权重设置随机概率（默认） || RoundRobin LoadBalance |轮询，按公约后的权重设置轮询比率||LeastActive LoadBalance |最少活跃调用数，相同活跃的随机||ConsistentHash LoadBalance| 一致性Hash，相同参数的请求总是发到同一提供者 | 12、Dubbo可以对结果进行缓存吗？ 可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。 13、当一个服务接口有多种实现时怎么做？ 当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。 14、Dubbo服务之间的调用是阻塞的吗？ 默认是同步等待结果阻塞的，支持异步调用。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。 15、Dubbo在安全机制方面是如何解决的 Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。 16、dubbo连接注册中心和直连的区别 在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。 17、dubbo通信协议dubbo协议为什么不能传大包 因dubbo协议采用单一长连接， 如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit=128MByte)，每条连接最大7MByte(不同的环境可能不一样，供参考)， 单个服务提供者的TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。 单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。 如果能接受，可以考虑使用，否则网络将成为瓶颈。","categories":[],"tags":[]},{"title":"Tomcat面试题整理","slug":"Tomcat面试题整理","date":"2019-04-12T02:10:11.876Z","updated":"2019-04-12T02:09:49.249Z","comments":true,"path":"2019/04/12/Tomcat面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/12/Tomcat面试题整理/","excerpt":"","text":"1、Tomcat 有哪几种Connector 运行模式(优化)？ bio：传统的Java I/O操作，同步且阻塞IO。 nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。 aio(nio.2)：JDK7开始支持，异步非阻塞IO。 apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。 2、Tomcat容器是如何创建servlet类实例？用到了什么原理？ 当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。 3、Tomcat内存调优 内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。具体设置如下：1JAVA_OPTS=\"$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4\" 其各项参数如下：12345678-Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置持久代大小为16m。 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比 4、垃圾回收策略调优 垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。具体设置如下：1JAVA_OPTS=\"$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100\" 具体的垃圾回收策略及相应策略的各项参数如下：串行收集器（JDK1.5以前主要的回收方式）-XX:+UseSerialGC:设置串行收集器并行收集器（吞吐量优先）示例：12345678910111213java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 -XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 并发收集器（响应时间优先） 示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 -XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 5、添加JMS远程监控 对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：12345-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址 -Dcom.sun.management.jmxremote.port=1090 设置JVM的JMS监控的端口 -Dcom.sun.management.jmxremote.ssl=false 设置JVM的JMS监控不实用SSL -Dcom.sun.management.jmxremote.authenticate=false 设置JVM的JMS监控不需要认证 6、请解释Tomcat中使用的连接器是什么? 在Tomcat中，使用了两种类型的连接器：HTTP连接器:它有许多可以更改的属性，以确定它的工作方式和访问功能，如重定向和代理转发AJP连接器:它以与HTTP连接器相同的方式工作，但是他们使用的是HTTP的AJP协议。AJP连接器通常通过插件技术mod_jk在Tomcat中实现 7、解释什么是Tomcat Valve? Tomcat Valve——Tomcat 4引入的新技术，它允许您将Java类的实例链接到一个特定的Catalina容器。 8、说明Tomcat配置了多少个Valve? Tomcat配置了四种类型的Valve： 访问日志 远程地址过滤 远程主机过滤器 客户请求记录器 9、请说明NAT协议的目的是什么? NAT协议的目的是将私有IP地址从公共IP地址隐藏起来，并给组织提供一定的安全性。","categories":[],"tags":[]},{"title":"MyBatis面试题整理","slug":"Mybatis面试题整理","date":"2019-04-04T09:57:32.000Z","updated":"2019-04-12T02:07:42.374Z","comments":true,"path":"2019/04/04/Mybatis面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/04/Mybatis面试题整理/","excerpt":"","text":"1、Mybaits的优点： 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接； 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。 能够与Spring很好的集成； 提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。 2、MyBatis框架的缺点： SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 3、MyBatis与Hibernate有哪些不同？ Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。 Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 4、#{}和${}的区别是什么？ #{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。 5、Mybatis是如何进行分页的？分页插件的原理是什么？ Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 6、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ 、、、、，加上动态sql的9个标签，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。 7、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个、、、标签，都会被解析为一个MappedStatement对象。Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 8、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？ Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。 9、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？ 第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？ Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？ 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。 12、Mybatis中如何执行批处理？使用BatchExecutor完成批处理。 13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？ Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。 SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 14、Mybatis中如何指定使用哪一种Executor执行器？ 在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。 15、Mybatis是否可以映射Enum枚举类？ Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。 16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？ 虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。 17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？ Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个、、、标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。 18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。","categories":[],"tags":[]},{"title":"Java基础面试题整理","slug":"Java基础面试题","date":"2019-04-04T09:57:31.998Z","updated":"2019-04-04T07:47:41.369Z","comments":true,"path":"2019/04/04/Java基础面试题/","link":"","permalink":"http://inerdstack.com/2019/04/04/Java基础面试题/","excerpt":"","text":"1、JAVA中的几种基本数据类型是什么，各自占用多少字节？浮点类型：float（4字节）、double（8个字）整数类型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）字符类型：char（2字节）布尔类型：boolean（4字节） 2、String类能被继承吗，为什么？不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 3、 String，Stringbuffer，StringBuilder的区别？String：不可变字符串；StringBuffer：可变字符串、效率低、线程安全；StringBuilder：可变字符序列、效率高、线程不安全；String可以空赋值，后者不行，报错如果要操作少量的数据用 String；多线程操作字符串缓冲区下操作大量数据 StringBuffer；单线程操作字符串缓冲区下操作大量数据 StringBuilder（推荐使用）。 4、java中==和equals和hashCode的区别 ==是运算符，用于比较两个变量是否相等。一般用于基本类型的比较 equals，是Objec类的方法，用于比较两个对象是否相等，默认Object类的equals方法是比较两个对象的地址，跟==的结果一样。 hashCode也是Object类的一个方法返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等） 5、int与integer的区别Integer是int的包装类，int则是java的一种基本数据类型Integer变量必须实例化后才能使用，而int变量不需要Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值Integer的默认值是null，int的默认值是0 6、什么是内部类？内部类的作用含义：可以将一个类的定义放在另一个类的定义的内部，这就是内部类。内部类的作用： 内部类可以很好的实现隐藏 内部类拥有外围类的所有元素的访问权限 可以实现多重继承(不要误解，这个是在一个外部类里面多个内部类继承不同基类达到一个外部类拥有多个基类的方法) 可以避免接口中的方法和同一个类中的方法同名的问题 7、抽象类和接口区别 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 抽象类里可以没有抽象方法 如果一个类里有抽象方法，那么这个类只能是抽象类 抽象方法要被实现，所以不能是静态的，也不能是私有的。 接口可继承接口，并可多继承接口，但类只能单根继承。 8、进程和线程的区别 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 9、泛型通配符extends与super的区别 &lt;? extends T&gt; 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入 &lt;? super T&gt;只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收 ? 既不能用于入参也不能用于返参 10、error和exception有什么区别error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 11、GC是什么? 为什么要有GCGC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 12、运行时异常与一般异常有何异同异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 13、描述一下JVM加载class文件的原理机制?JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 14、&amp;和&amp;&amp;的区别&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and） 15.什么是值传递和引用传递？对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。","categories":[],"tags":[]},{"title":"Spring面试题整理","slug":"Spring面试题整理","date":"2019-04-04T09:57:31.995Z","updated":"2019-04-12T02:04:40.300Z","comments":true,"path":"2019/04/04/Spring面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/04/Spring面试题整理/","excerpt":"","text":"1. 使用Spring框架的好处是什么？ 轻量：Spring 是轻量的，基本的版本大约2MB。 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 容器：Spring 包含并管理应用中对象的生命周期和配置。 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。 2. Spring由哪些模块组成以下是Spring 框架的基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 3、BeanFactory和ApplicationContext有什么区别？BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能： 继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 （2） BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。 ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。 （3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。 4、 解释Spring支持的几种bean的作用域。Spring容器中的bean可以分为5个范围： singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。 prototype：为每一个bean请求提供一个实例。 request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。 5、Spring框架中的单例Beans是线程安全的么？ Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。 6、Spring 框架中都用到了哪些设计模式？（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；（2）单例模式：Bean默认为单例模式。（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；（4）模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。 7、解释一下Spring AOP里面的几个名词：（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add、search。（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。 8、Spring中有哪些不同的通知类型通知(advice)是你在你的程序中想要应用在其他模块中的横切关注点的实现。Advice主要有以下5种类型： 前置通知(Before Advice): 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 @Before 注解使用这个Advice。 返回之后通知(After Retuning Advice): 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 @AfterReturning 关注使用它。 抛出（异常）后执行通知(After Throwing Advice): 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通用 @AfterThrowing 注解来使用。 后置通知(After Advice): 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 @After 注解使用。 围绕通知(Around Advice): 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过 @Around注解使用。 9、 什么是Spring的依赖注入依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 10、有哪些不同类型的IOC（依赖注入）方式？ 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 11、哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 12、 如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。 SpringMVC相关：https://blog.csdn.net/a745233700/article/details/80963758","categories":[],"tags":[]}]}