{"meta":{"title":"ThisLX","subtitle":"the stack of it nerds","description":"ThisLX Blog","author":"ThisLX","url":"http://inerdstack.com","root":"/"},"pages":[],"posts":[{"title":"Mybatis面试题整理","slug":"Mybatis面试题整理","date":"2019-04-04T09:57:32.000Z","updated":"2019-04-04T09:57:23.036Z","comments":true,"path":"2019/04/04/Mybatis面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/04/Mybatis面试题整理/","excerpt":"","text":"2、Mybaits的优点：（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。（4）能够与Spring很好的集成；（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。3、MyBatis框架的缺点：（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 5、MyBatis与Hibernate有哪些不同？（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。6、#{}和${}的区别是什么？ #{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；Mybatis在处理${}时，就是把${}替换成变量的值。使用#{}可以有效的防止SQL注入，提高系统安全性。10、Mybatis是如何进行分页的？分页插件的原理是什么？ Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？答：、、、、，加上动态sql的9个标签，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。","categories":[],"tags":[]},{"title":"Java基础面试题整理","slug":"Java基础面试题","date":"2019-04-04T09:57:31.998Z","updated":"2019-04-04T07:47:41.369Z","comments":true,"path":"2019/04/04/Java基础面试题/","link":"","permalink":"http://inerdstack.com/2019/04/04/Java基础面试题/","excerpt":"","text":"1、JAVA中的几种基本数据类型是什么，各自占用多少字节？浮点类型：float（4字节）、double（8个字）整数类型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）字符类型：char（2字节）布尔类型：boolean（4字节） 2、String类能被继承吗，为什么？不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 3、 String，Stringbuffer，StringBuilder的区别？String：不可变字符串；StringBuffer：可变字符串、效率低、线程安全；StringBuilder：可变字符序列、效率高、线程不安全；String可以空赋值，后者不行，报错如果要操作少量的数据用 String；多线程操作字符串缓冲区下操作大量数据 StringBuffer；单线程操作字符串缓冲区下操作大量数据 StringBuilder（推荐使用）。 4、java中==和equals和hashCode的区别 ==是运算符，用于比较两个变量是否相等。一般用于基本类型的比较 equals，是Objec类的方法，用于比较两个对象是否相等，默认Object类的equals方法是比较两个对象的地址，跟==的结果一样。 hashCode也是Object类的一个方法返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等） 5、int与integer的区别Integer是int的包装类，int则是java的一种基本数据类型Integer变量必须实例化后才能使用，而int变量不需要Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值Integer的默认值是null，int的默认值是0 6、什么是内部类？内部类的作用含义：可以将一个类的定义放在另一个类的定义的内部，这就是内部类。内部类的作用： 内部类可以很好的实现隐藏 内部类拥有外围类的所有元素的访问权限 可以实现多重继承(不要误解，这个是在一个外部类里面多个内部类继承不同基类达到一个外部类拥有多个基类的方法) 可以避免接口中的方法和同一个类中的方法同名的问题 7、抽象类和接口区别 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 抽象类里可以没有抽象方法 如果一个类里有抽象方法，那么这个类只能是抽象类 抽象方法要被实现，所以不能是静态的，也不能是私有的。 接口可继承接口，并可多继承接口，但类只能单根继承。 8、进程和线程的区别 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束 线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 9、泛型通配符extends与super的区别 &lt;? extends T&gt; 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入 &lt;? super T&gt;只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收 ? 既不能用于入参也不能用于返参 10、error和exception有什么区别error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 11、GC是什么? 为什么要有GCGC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 12、运行时异常与一般异常有何异同异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 13、描述一下JVM加载class文件的原理机制?JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 14、&amp;和&amp;&amp;的区别&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and） 15.什么是值传递和引用传递？对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。","categories":[],"tags":[]},{"title":"Spring面试题整理","slug":"Spring面试题整理","date":"2019-04-04T09:57:31.995Z","updated":"2019-04-04T09:56:58.187Z","comments":true,"path":"2019/04/04/Spring面试题整理/","link":"","permalink":"http://inerdstack.com/2019/04/04/Spring面试题整理/","excerpt":"","text":"1. 使用Spring框架的好处是什么？ 轻量：Spring 是轻量的，基本的版本大约2MB。 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 容器：Spring 包含并管理应用中对象的生命周期和配置。 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。 2. Spring由哪些模块组成以下是Spring 框架的基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 3、BeanFactory和ApplicationContext有什么区别？BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能： 继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 （2） BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。 ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。 （3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。 4、 解释Spring支持的几种bean的作用域。Spring容器中的bean可以分为5个范围： singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。 prototype：为每一个bean请求提供一个实例。 request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。 5、Spring框架中的单例Beans是线程安全的么？ Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。 6、Spring 框架中都用到了哪些设计模式？（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；（2）单例模式：Bean默认为单例模式。（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；（4）模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。 7、解释一下Spring AOP里面的几个名词：（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add、search。（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。 8、Spring中有哪些不同的通知类型通知(advice)是你在你的程序中想要应用在其他模块中的横切关注点的实现。Advice主要有以下5种类型： 前置通知(Before Advice): 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 @Before 注解使用这个Advice。 返回之后通知(After Retuning Advice): 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 @AfterReturning 关注使用它。 抛出（异常）后执行通知(After Throwing Advice): 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通用 @AfterThrowing 注解来使用。 后置通知(After Advice): 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 @After 注解使用。 围绕通知(Around Advice): 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过 @Around注解使用。 9、 什么是Spring的依赖注入依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 10、有哪些不同类型的IOC（依赖注入）方式？ 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 11、哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 12、 如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。","categories":[],"tags":[]},{"title":"XSS防护","slug":"Welcome","date":"2019-03-18T07:16:22.491Z","updated":"2019-03-18T13:56:01.599Z","comments":true,"path":"2019/03/18/Welcome/","link":"","permalink":"http://inerdstack.com/2019/03/18/Welcome/","excerpt":"","text":"1. XSS介绍XSS（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。跨站脚本的重点不在“跨站”上，而在于“跨站”上。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。 2. XSS分类2.1 反射型XSS反射型XSS主要表现在浏览器的展示层面上，并没有将脚本数据持久化到数据库中，攻击者通过拦截服务器返回给页面的数据，利用工具在服务器返回的数据中加入攻击脚本，进而在页面上进行展示。严重的还可以窃取用户密码等信息。 2.1 存储型XSS顾名思义，它和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与JS解析执行，于是触发了XSS攻击。 3. 安全测试工具如果测试系统是否含有此漏洞，可以使用抓包工具进行测试，在这里我推荐一个工具，也是大多数安全测试人员使用的工具，工具名称为Burpsuite。想要使用此工具还要需要配置一下浏览器。这里主要介绍Burpsuite+Firefox浏览器。配置方法：http://www.cnblogs.com/slpawn/p/7235105.htmlBurpsuite和Firefox证书下载路径：https://download.csdn.net/download/li521wang/10938753具体的使用方法就不这里详细讲了。 4. 代码过滤XSS攻击利用Filter进行XSS过滤。首先先增加几个配置类管理XSS过滤参数以及过滤的内容。 4.1. XSSSecurityManager 安全过滤配置管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * @Author: LX 17839193044@162.com * @Description: 安全过滤配置管理类，由XSSSecurityManger修改。（admin迁移至此） * @Date: 2019/1/24 14:55 * @Version: V1.0 */@Slf4jpublic class XSSSecurityManager &#123; /** * REGEX：校验正则表达式 */ public static String REGEX; public static String[] REGEXS = new String[15]; /** * 特殊字符匹配 */ public static Pattern XSS_PATTERN; /** * 设置私有构造方法 */ private XSSSecurityManager() &#123; &#125; /** * @Author: LX 17839193044@162.com * @Description: 初始化过滤匹配的字符 * @Date: 2019/1/24 15:20 * @Version: V1.0 */ public static void init() &#123; log.info(\"XSSSecurityManager.initConfig(String path) begin\"); // 匹配含有字符： alert REGEXS[0] = \".*[A|a][L|l][E|e][R|r][T|t]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： window.location = REGEXS[1] = \".*[W|w][I|i][N|n][D|d][O|o][W|w]\\\\.[L|l][O|o][C|c][A|a][T|t][I|i][O|o][N|n]\\\\s*=.*\"; // 匹配含有字符：style = x:ex pression ( ) REGEXS[2] = \".*[S|s][T|t][Y|y][L|l][E|e]\\\\s*=.*[X|x]:[E|e][X|x].*[P|p][R|r][E|e][S|s]&#123;1,2&#125;[I|i][O|o][N|n]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： document.cookie REGEXS[3] = \".*[D|d][O|o][C|c][U|u][M|m][E|e][N|n][T|t]\\\\.[C|c][O|o]&#123;2&#125;[K|k][I|i][E|e].*\"; // 匹配含有字符： eval( ) REGEXS[4] = \".*[E|e][V|v][A|a][L|l]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： unescape() REGEXS[5] = \".*[U|u][N|n][E|e][S|s][C|c][A|a][P|p][E|e]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： execscript( ) REGEXS[6] = \".*[E|e][X|x][E|e][C|c][S|s][C|c][R|r][I|i][P|p][T|t]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： msgbox( ) REGEXS[7] = \".*[M|m][S|s][G|g][B|b][O|o][X|x]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： confirm( ) REGEXS[8] = \".*[C|c][O|o][N|n][F|f][I|i][R|r][M|m]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： prompt( ) REGEXS[9] = \".*[P|p][R|r][O|o][M|m][P|p][T|t]\\\\s*\\\\(.*\\\\).*\"; // 匹配含有字符： &lt;script&gt; &lt;/script&gt; REGEXS[10] = \".*&lt;[S|s][C|c][R|r][I|i][P|p][T|t]&gt;.*&lt;/[S|s][C|c][R|r][I|i][P|p][T|t]&gt;.*\"; // 匹配含有字符： 含有一个符号： \" REGEXS[11] = \"[.&amp;[^\\\"]]*\\\"[.&amp;[^\\\"]]*\"; // 匹配含有字符： 含有一个符号： ' REGEXS[12] = \"[.&amp;[^']]*'[.&amp;[^']]*\"; // 匹配含有字符： 含有回车换行 和 &lt;script&gt; &lt;/script&gt; REGEXS[13] = \".&amp;[^a]]|[|a|\\n|\\r\\n|\\r|\\u0085|\\u2028|\\u2029]]*&lt;[S|s][C|c][R|r][I|i][P|p][T|t]&gt;.*&lt;/[S|s][C|c][R|r][I|i][P|p][T|t]&gt;[[.&amp;[^a]]|[|a|\\n|\\r\\n|\\r|\\u0085|\\u2028|\\u2029]]*\"; // 匹配特殊sql字符 REGEXS[14] = \"(?:')|(?:--)|(/\\\\*(?:.|[\\\\n\\\\r])*?\\\\*/)|\" + \"(.*\\\\b(select|update|and|or|delete|insert|trancate|char|into|substr|ascii|declare|exec|count|master|into|drop|execute)\\\\b.*)\"; StringBuffer sb = new StringBuffer(\"^\"); for (String tmp : REGEXS) &#123; tmp = tmp.replaceAll(\"\\\\\\\\\\\\\\\\\", \"\\\\\\\\\"); sb.append(tmp); sb.append(\"|\"); &#125; if (sb.charAt(sb.length() - 1) == '|') &#123; REGEX = sb.substring(0, sb.length() - 1) + \"$\"; log.info(\"安全匹配规则\" + REGEX); &#125; else &#123; log.error(\"安全过滤配置文件加载失败:正则表达式异常 \" + sb.toString()); &#125; // 生成匹配器 XSS_PATTERN = Pattern.compile(REGEX); log.info(\"XSSSecurityManager.initConfig(String path) end\"); &#125; /** * 匹配字符是否含特殊字符 * * @param text * @return */ public static boolean matches(String text) &#123; if (StringUtils.isBlank(text)) &#123; return false; &#125; return XSS_PATTERN.matcher(text).matches(); &#125;&#125; 4.2. XSSSecurityConfig 开关配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @Author: LX 17839193044@162.com * @Description: XSS配置类 * @Date: 2019/1/24 14:54 * @Version: V1.0 */public class XSSSecurityConfig &#123; private XSSSecurityConfig() &#123; &#125; /** * CHECK_HEADER：是否开启header校验 */ public static boolean IS_CHECK_HEADER = false; /** * CHECK_PARAMETER：是否开启parameter校验 */ public static boolean IS_CHECK_PARAMETER = true; /** * IS_LOG：是否记录日志 */ public static boolean IS_LOG = true; /** * IS_LOG：是否中断操作 */ public static boolean IS_CHAIN = false; /** * REPLACE：是否开启替换 */ public static boolean REPLACE = true; /** * FILTER_ERROR_PAGE:过滤后错误页面 */ public static String FILTER_ERROR_PAGE2 = \"/error\"; /** * IS_FILTER_REFERER：是否开启防盗链 */ public static boolean IS_FILTER_REFERER = false;&#125; 4.3. XssHttpServletRequestWrapper 自定义XSS过滤wrapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * @Author: LX 17839193044@162.com * @Description: 自定义XSS过滤wrapper * @Date: 2019/1/24 14:50 * @Version: V1.0 */@Slf4jpublic class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; public XssHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; @Override public String getHeader(String name) &#123; String value = super.getHeader(name);// // 若开启特殊字符替换，对特殊字符进行替换// if (XSSSecurityConfig.REPLACE &amp;&amp; StringUtils.isNotBlank(value)) &#123;// return stringFilter(value);// &#125; return value; &#125; @Override public String getQueryString() &#123; String queryString = super.getQueryString(); // 若开启特殊字符替换，对特殊字符进行替换 if (XSSSecurityConfig.REPLACE &amp;&amp; StringUtils.isNotBlank(queryString)) &#123; return stringFilter(queryString); &#125; return StringEscapeUtils.escapeHtml4(super.getQueryString()); &#125; @Override public String getParameter(String name) &#123; String value = super.getParameter(name); // 若开启特殊字符替换，对特殊字符进行替换 if (XSSSecurityConfig.REPLACE &amp;&amp; StringUtils.isNotBlank(value)) &#123; return stringFilter(value); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String[] values = super.getParameterValues(name); if (values != null) &#123; int length = values.length; String[] escapseValues = new String[length]; for (int i = 0; i &lt; length; i++) &#123; escapseValues[i] = StringEscapeUtils.escapeHtml4(values[i]); &#125; return escapseValues; &#125; return super.getParameterValues(name); &#125; /** * 没有违规的数据，就返回false; * 若存在违规数据，根据配置信息判断是否跳转到错误页面 * * @return * @throws IOException * @throws ServletException */ public boolean validateParameter() &#123; // 开始header校验，对header信息进行校验 if (XSSSecurityConfig.IS_CHECK_HEADER) &#123; if (this.checkHeader()) &#123; return true; &#125; &#125; // 开始parameter校验，对parameter信息进行校验 if (XSSSecurityConfig.IS_CHECK_PARAMETER) &#123; if (this.checkParameter()) &#123; return true; &#125; &#125; return false; &#125; /** * 没有违规的数据，就返回false; * * @return */ private boolean checkHeader() &#123; Enumeration&lt;String&gt; headerParams = this.getHeaderNames(); while (headerParams.hasMoreElements()) &#123; String headerName = headerParams.nextElement(); String headerValue = this.getHeader(headerName); if (XSSSecurityManager.matches(headerValue)) &#123; return true; &#125; &#125; return false; &#125; /** * 没有违规的数据，就返回false; * * @return */ private boolean checkParameter() &#123; Map&lt;String, String[]&gt; submitParams = this.getParameterMap(); Set&lt;String&gt; submitNames = submitParams.keySet(); for (String submitName : submitNames) &#123; String[] submitValues = submitParams.get(submitName); for (String submitValue : submitValues) &#123; try &#123; submitValue = StringEscapeUtils.unescapeHtml4(submitValue); log.debug(submitName + \":\" + submitValue + \"----\" + XSSSecurityManager.matches(submitValue)); if (XSSSecurityManager.matches(submitValue)) &#123; return true; &#125; &#125; catch (Exception e) &#123; log.info(\"地址解码异常:\" + submitValue); return false; &#125; &#125; &#125; return false; &#125; /** * 过滤字符串里的的特殊字符 * * @param str 要过滤的字符串 * @return 过滤后的字符串 */ public static String stringFilter(String str) &#123; String temp = StringUtils.replace(str, \"%27\", \"\"); temp = StringUtils.replace(temp, \"*\", \"\"); temp = StringUtils.replace(temp, \"\\\"\", \"&amp;quot;\"); temp = StringUtils.replace(temp, \"'\", \"\"); temp = StringUtils.replace(temp, \"\\\\\\\"\", \"\"); temp = StringUtils.replace(temp, \";\", \"\"); temp = StringUtils.replace(temp, \"&lt;\", \"&amp;lt;\"); temp = StringUtils.replace(temp, \"&gt;\", \"&amp;gt;\"); temp = StringUtils.replace(temp, \"(\", \"\"); temp = StringUtils.replace(temp, \")\", \"\"); temp = StringUtils.replace(temp, \"&#123;\", \"\"); temp = StringUtils.replace(temp, \"&#125;\", \"\"); return temp.trim(); &#125;&#125; 4.4. XssFilter 过滤器，拦截所有请求，对Header、Parameter进行过滤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @Author: LX 17839193044@162.com * @Description: XSS过滤器 拦截所有请求，对Header、Parameter进行过滤 * @Date: 2019/1/24 14:51 * @Version: V1.0 */@Slf4jpublic class XssFilter implements Filter &#123; /** * @Author: LX 17839193044@162.com * @Description: 项目启动时初始化 * @Date: 2019/1/24 16:11 * @Version: V1.0 */ @Override public void init(FilterConfig filterConfig) &#123; //初始化XSS过滤词库 XSSSecurityManager.init(); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; // LX 17839193044@162.com 此处增加CSRF过滤 下编讲 // http信息封装类 XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper(req); String pageLink = xssRequest.getServletPath(); if (StringUtils.isNotBlank(pageLink)) &#123; // 对request信息进行封装并进行校验工作，若校验失败（含非法字符）， // 根据配置信息进行日志记录和请求中断处理 if (!pageLink.equals(XSSSecurityConfig.FILTER_ERROR_PAGE2) &amp;&amp; xssRequest.validateParameter()) &#123; //判断是否记录日志 if (XSSSecurityConfig.IS_LOG) &#123; // 记录攻击访问日志 可使用数据库、日志、文件等方式 log.error(\"访问IP:&#123;&#125;,请求后缀:&#123;&#125;,查询参数:&#123;&#125;\", request.getRemoteAddr(), pageLink, xssRequest.getQueryString()); &#125; if (XSSSecurityConfig.IS_CHAIN) &#123; //进行页面跳转 request.getRequestDispatcher(XSSSecurityConfig.FILTER_ERROR_PAGE2).forward(request, resp); return; &#125; chain.doFilter(xssRequest, resp); &#125; else &#123; chain.doFilter(xssRequest, resp); &#125; &#125; else &#123; chain.doFilter(xssRequest, resp); &#125; &#125; /** * @Author: LX 17839193044@162.com * @Description: 生命周期结束时调用 * @Date: 2019/1/24 16:11 * @Version: V1.0 */ @Override public void destroy() &#123; &#125;&#125; 4.5. web.xml 最重要的一步，不解释。123456789&lt;!-- XSS过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.***.XssFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 到此处将修改后的代码部署到服务器。利用Burpsuite再次进行安全测试，XSS攻击已经被我们过滤了。如果大家还有其他比较好的XSS防护对策，可以分享一下。万分感谢！","categories":[],"tags":[]}]}